---
import path from 'node:path'

import StarlightSidebar from '@astrojs/starlight/components/Sidebar.astro'

import Copyright from '~/components/Copyright.astro'

const basePath = path.dirname(`/${Astro.props.id}`)

function getIndexEntry<
	T extends { type: 'link', href: string }
>(
	entries: T[],
): T | undefined
{
	// Filter out non-link entries
	entries = entries.filter((entry) => entry.type === 'link')

	if (entries.length <= 0)
	{
		// No link entry
		return undefined
	}

	// Get base path for level link entries
	const levelBasePath = entries
		.map((entry) => entry.href)
		.reduce<string | undefined>(
			(basePath, href) =>
			{
				if (!basePath)
				{
					return href
				}

				const splitBasePath = basePath.split('/')
				const splitHref = href.split('/')
				return splitBasePath
					.filter((part, index) => part === splitHref[index])
					.join('/')
			},
			undefined,
		) as string

	// Get index or first entry
	return entries.find((entry) => entry.href === levelBasePath)

}

type SidebarReducedEntries = [ any[], { hasBackLink: boolean } ]

function filterSidebar(inputEntries: any[], basePath: string, level: number = 1): SidebarReducedEntries
{
	// Recursively applies to list of entries

	const basePathLevels = basePath.split('/').length - 1
	const reducedEntries = inputEntries
		.reduce<SidebarReducedEntries>(
			(previous, entry) =>
			{
				const [ entries, options ] = previous

				if (entry.type === 'link')
				{
					if (entry.href.startsWith(basePath))
					{
						entries.push(entry)
						return [ entries, options ]
					}

					if (level <= 1)
					{
						if (entry.href.startsWith('http'))
						{
							entries.push(entry)
							return [ entries, options ]
						}

						if (entry.href === '/' && basePathLevels <= 1)
						{
							// Keep home link
							entries.push({
								...entry,
								label: '← ' + entry.label,
							})
							return [ entries, options ]
						}
					}

					return [ entries, options ]
				}

				if (entry.type == 'group')
				{
					const [ filteredEntries, _ ] = filterSidebar(entry.entries, basePath, level + 1)

					if (filteredEntries.length <= 0)
					{
						// Skip empty group
						return [ entries, options ]
					}

					if (level > basePathLevels && level >= 2)
					{
						// Fold higher level groups
						// Start from level 2

						// Get index or first entry
						const indexOrFirstEntry = getIndexEntry(entry.entries as any[]) || (entry.entries as any[])[0]

						// Replace group with entry
						entries.push({
							...indexOrFirstEntry,
							label: `${indexOrFirstEntry.label} : ${level} >= ${basePathLevels}`,
							attrs: {
								class: 'large',
							},
						})
						return [ entries, options ]
					}

					if (filteredEntries.length === 1)
					{
						// Group has only one entry

						if (level < basePathLevels - 1 || level > basePathLevels)
						{
							// Replace group with entry
							entries.push({
								...filteredEntries[0],
								label: (
									filteredEntries[0].attrs?.slash
										? filteredEntries[0].label
										: entry.label + ' / ' + filteredEntries[0].label
								),
								attrs: {
									...filteredEntries[0].attrs,
									...(filteredEntries[0].type === 'link' ? { class: 'large' } : {}),
									slash: true,
								},
							})

							return [ entries, options ]
						}
						else if (level === basePathLevels - 1)
						{
							// Get index or first entry
							const indexOrFirstEntry = (
								getIndexEntry(entry.entries as any[]) ||
								filteredEntries.find((subEntry) => subEntry.type === 'link') ||
								null
							)

							if (indexOrFirstEntry)
							{
								// Add link to go back to group
								entries.push({
									...indexOrFirstEntry,
									label: '← ' + indexOrFirstEntry.label,
									attrs: {
										class: 'large',
									},
								})
							}
							else
							{
								// Add link to go back to group
								entries.push({
									type: 'link',
									label: '← xxx',
									attrs: {
										class: 'large',
									},
								})
							}

							// Replace group with entry
							entries.push({
								...filteredEntries[0],
								label: (
									filteredEntries[0].attrs?.slash
										? filteredEntries[0].label
										: entry.label + ' / ' + filteredEntries[0].label
								),
								attrs: {
									...filteredEntries[0].attrs,
									...(filteredEntries[0].type === 'link' ? { class: 'large' } : {}),
									slash: true,
								},
							})

							return [ entries, options ]
						}
					}

					entries.push({
						...entry,
						entries: filteredEntries,
					})
					return [ entries, options ]
				}

				// Unknown entry type
				entries.push({
					...entry,
					label: `?_${entry.label}`,
				})
				return [ entries, options ]
			},
			[ [], { hasBackLink: false } ],
		)

	return reducedEntries
}

Astro.props.sidebar = filterSidebar(Astro.props.sidebar, basePath)[0]
---

<div class="sidebar-wrapper">
	<StarlightSidebar {...(Astro.props as any)} />

	<div class="md:mt-4">
		<Copyright shortText={true} />
	</div>
</div>

<style lang="scss">
	.sidebar-wrapper {
		display: contents;
	}
</style>
